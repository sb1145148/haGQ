<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <title>haGQ - å…¨çƒåœ°éœ‡ç›‘æµ‹</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root {
      --primary-color: #3498db;
      --danger-color: #e74c3c;
      --warning-color: #f39c12;
      --success-color: #2ecc71;
      --light-color: #ecf0f1;
      --dark-color: #2c3e50;
    }
    
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f2f2f2;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    
    #map {
      flex: 1;
      height: 100%;
      position: relative;
    }
    
    #sidebar {
      width: 420px;
      background: #fff;
      box-shadow: -2px 0 5px rgba(0,0,0,.1);
      padding: 15px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }
    
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    
    .header h1 {
      margin: 0;
      color: var(--dark-color);
      font-size: 24px;
    }
    
    .item {
      background: #f7f7f7;
      margin: 8px 0;
      padding: 12px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      transition: all 0.2s;
      border-left: 4px solid #3498db;
    }
    
    .item:hover {
      background: #e9f7fe;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .mag {
      font-weight: bold;
      font-size: 18px;
      margin-right: 8px;
      min-width: 50px;
    }
    
    .dist {
      color: #666;
      margin-left: 10px;
      font-size: 14px;
    }
    
    .intensity {
      margin-left: 10px;
      font-size: 14px;
      font-weight: bold;
    }
    
    .icon {
      width: 28px;
      height: 28px;
      display: inline-block;
      margin-right: 10px;
    }
    
    .setting {
      background: #e9e9e9;
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 15px;
    }
    
    label {
      margin-right: 10px;
      font-weight: 500;
    }
    
    input, select {
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    
    input {
      width: 120px;
    }
    
    button {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #2980b9;
    }
    
    #status {
      font-size: 14px;
      color: #555;
      margin-left: 10px;
    }
    
    audio {
      display: none;
    }
    
    #mapLoading {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,.35);
      color: #fff;
      font-size: 18px;
      font-weight: bold;
      padding: 6px 22px;
      border-radius: 8px;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0,0,0,.10);
      pointer-events: none;
      transition: opacity .3s;
    }
    
    #mapClock {
      position: absolute;
      right: 10px;
      bottom: 10px;
      background: rgba(255,255,255,0.85);
      font-size: 16px;
      padding: 6px 18px;
      border-radius: 8px;
      border: 1px solid #d9d9d9;
      z-index: 1200;
      box-shadow: 0 2px 8px rgba(0,0,0,.07);
      display: flex;
      align-items: center;
    }
    
    #clockSwitchBtn {
      margin-left: 12px;
      background: #eee;
      border-radius: 5px;
      border: 1px solid #ccc;
      font-size: 14px;
      padding: 1px 8px;
      cursor: pointer;
      transition: background .2s;
    }
    
    #clockSwitchBtn:hover {
      background: #d7eaff;
    }
    
    .copy-info {
      background: #e8f4fd;
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 10px;
      font-size: 14px;
      color: #2c3e50;
    }
    
    .filter-section {
      margin: 10px 0;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 6px;
    }
    
    .filter-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 8px;
    }
    
    .filter-controls label {
      display: flex;
      align-items: center;
      font-size: 14px;
    }
    
    .filter-controls input {
      width: 60px;
      margin-left: 5px;
    }
    
    .quake-details {
      display: none;
      background: white;
      padding: 15px;
      border-radius: 6px;
      margin-top: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .quake-details h4 {
      margin-top: 0;
      color: var(--dark-color);
    }
    
    .quake-details table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .quake-details td {
      padding: 5px 0;
      border-bottom: 1px solid #eee;
    }
    
    .quake-details td:first-child {
      font-weight: bold;
      width: 40%;
    }
    
    .timeline-container {
      margin-top: 15px;
      background: white;
      padding: 15px;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .timeline {
      height: 60px;
      position: relative;
      margin-top: 10px;
    }
    
    .timeline-marker {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      transform: translateX(-50%);
      cursor: pointer;
    }
    
    .timeline-label {
      position: absolute;
      top: 15px;
      font-size: 10px;
      transform: translateX(-50%);
      white-space: nowrap;
    }
    
    .source-badge {
      background: #e1f5fe;
      color: #01579b;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 12px;
      margin-left: 8px;
    }
    
    .quake-time {
      color: #666;
      font-size: 12px;
      margin-left: 8px;
    }
    
    .map-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: white;
      padding: 8px;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .map-controls button {
      margin: 2px;
      padding: 4px 8px;
      font-size: 12px;
    }
    
    .alert-banner {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(231, 76, 60, 0.9);
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      z-index: 1000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      display: none;
      font-weight: bold;
    }
    
    .replay-controls {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      padding: 10px 15px;
      border-radius: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      display: none;
      align-items: center;
      gap: 10px;
    }
    
    .replay-controls button {
      padding: 4px 8px;
      font-size: 12px;
    }
    
    .replay-slider {
      width: 200px;
    }
    
    .replay-time {
      font-size: 14px;
      font-weight: bold;
      min-width: 150px;
      text-align: center;
    }
    
    .replay-speed {
      width: 80px;
    }
    
    @media (max-width: 768px) {
      body {
        flex-direction: column;
      }
      
      #sidebar {
        width: 100%;
        height: 40%;
      }
      
      #map {
        height: 60%;
      }
      
      .replay-controls {
        bottom: 10px;
        left: 10px;
        transform: none;
        flex-wrap: wrap;
        width: calc(100% - 20px);
      }
      
      .replay-slider {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div id="map">
    <div id="mapLoading">æœªåŠ è½½å®Œæˆ</div>
    <div id="mapClock">
      <span id="clockLabel"></span>
      <button id="clockSwitchBtn" onclick="switchClockMode()">åˆ‡æ¢ä¸ºæœ¬åœ°æ—¶é—´</button>
    </div>
    <div class="map-controls">
      <button onclick="switchMapStyle('osm')">ä¸–ç•Œåœ°å›¾</button>
      <button onclick="switchMapStyle('gaode')">é«˜å¾·åœ°å›¾</button>
      <button onclick="switchMapStyle('satellite')">å«æ˜Ÿåœ°å›¾</button>
      <button onclick="toggleReplay()" id="replayToggleBtn">åœ°éœ‡å›æ”¾</button>
    </div>
    <div class="alert-banner" id="alertBanner">
      <span id="alertText"></span>
      <button onclick="closeAlert()" style="margin-left: 10px; background: white; color: #e74c3c;">å…³é—­</button>
    </div>
    <div class="replay-controls" id="replayControls">
      <button onclick="replayFirst()" title="è·³åˆ°å¼€å§‹">â®</button>
      <button onclick="replayPrev()" title="ä¸Šä¸€æ­¥">â—€</button>
      <button onclick="toggleReplayPlay()" id="replayPlayBtn">â–¶</button>
      <button onclick="replayNext()" title="ä¸‹ä¸€æ­¥">â–¶</button>
      <button onclick="replayLast()" title="è·³åˆ°ç»“æŸ">â­</button>
      <input type="range" min="0" max="100" value="0" class="replay-slider" id="replaySlider">
      <span class="replay-time" id="replayTime">--</span>
      <select class="replay-speed" id="replaySpeed">
        <option value="5000">0.2x</option>
        <option value="2000" selected>0.5x</option>
        <option value="1000">1x</option>
        <option value="500">2x</option>
        <option value="250">4x</option>
      </select>
      <button onclick="toggleReplay()" style="background: #e74c3c;">å…³é—­å›æ”¾</button>
    </div>
  </div>
  <div id="sidebar">
    <div class="header">
      <h1>haGQ - å…¨çƒåœ°éœ‡ç›‘æµ‹</h1>
      <span id="status"></span>
    </div>
    
    <div class="setting">
      <label>çº¬åº¦ï¼š<input id="lat" type="number" step="0.0001" value="32"></label>
      <label>ç»åº¦ï¼š<input id="lon" type="number" step="0.0001" value="110"></label>
      <button onclick="savePos()">ä¿å­˜</button>
      <span id="saved"></span>
      <br>
      <label>æ•°æ®æºï¼š</label>
      <select id="sourceSelect" onchange="fetchQuakeData()">
        <option value="all">å…¨éƒ¨æ•°æ®æº</option>
        <option value="cenc">ä¸­å›½åœ°éœ‡å°ç½‘</option>
        <option value="usgs">USGSå…¨çƒåœ°éœ‡</option>
        <option value="emsc">EMSCå…¨çƒåœ°éœ‡</option>
        <option value="p2pquake">P2PQuake</option>
        <option value="jma">æ—¥æœ¬æ°”è±¡å…</option>
      </select>
    </div>
    
    <div class="filter-section">
      <strong>ç­›é€‰æ¡ä»¶ï¼š</strong>
      <div class="filter-controls">
        <label>æœ€å°éœ‡çº§ï¼š<input id="minMag" type="number" min="0" max="10" step="0.1" value="0" onchange="applyFilters()"></label>
        <label>æœ€å¤§è·ç¦»ï¼š<input id="maxDist" type="number" min="0" step="100" value="10000" onchange="applyFilters()"> km</label>
        <label>æ—¶é—´èŒƒå›´ï¼š<input id="timeRange" type="number" min="1" value="24" onchange="applyFilters()"> å°æ—¶</label>
      </div>
    </div>
    
    <div class="copy-info" id="copyInfo">å¯ç‚¹å‡»å†å²åœ°éœ‡é¡¹å¤åˆ¶ä¿¡æ¯</div>
    
    <div class="quake-details" id="quakeDetails">
      <h4>åœ°éœ‡è¯¦æƒ…</h4>
      <table>
        <tr><td>åœ°ç‚¹ï¼š</td><td id="detailPlace"></td></tr>
        <tr><td>éœ‡çº§ï¼š</td><td id="detailMag"></td></tr>
        <tr><td>æ—¶é—´ï¼š</td><td id="detailTime"></td></tr>
        <tr><td>çƒˆåº¦ï¼š</td><td id="detailIntensity"></td></tr>
        <tr><td>è·ç¦»ï¼š</td><td id="detailDistance"></td></tr>
        <tr><td>Pæ³¢åˆ°è¾¾ï¼š</td><td id="detailPWave"></td></tr>
        <tr><td>Sæ³¢åˆ°è¾¾ï¼š</td><td id="detailSWave"></td></tr>
        <tr><td>æ•°æ®æºï¼š</td><td id="detailSource"></td></tr>
      </table>
    </div>
    
    <h3 id="listTitle">å†å²åœ°éœ‡ï¼ˆæœ€è¿‘50æ¡ï¼‰</h3>
    <div id="list"></div>
    
    <div class="timeline-container">
      <strong>æ—¶é—´çº¿</strong>
      <div class="timeline" id="timeline"></div>
    </div>
  </div>
  
  <!-- å¤šç§éŸ³æ•ˆ -->
  <audio id="alert" src="data:audio/wav;base64,UklGRoABAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8A" preload="auto"></audio>
  <audio id="countdown" preload="auto"></audio>
  <audio id="srev" preload="auto"></audio>
  
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // æ—¶é’Ÿç›¸å…³
    var clockMode = "bj";
    function getBJTime() {
      let now = new Date();
      let bj = new Date(now.getTime() + (8 - now.getTimezoneOffset()/60)*3600*1000 - now.getTimezoneOffset()*60*1000);
      return bj;
    }
    function formatTime(dt) {
      return dt.getFullYear() + '-' + ('0'+(dt.getMonth()+1)).slice(-2) + '-' +
        ('0'+dt.getDate()).slice(-2) + ' ' + ('0'+dt.getHours()).slice(-2) + ':' +
        ('0'+dt.getMinutes()).slice(-2) + ':' + ('0'+dt.getSeconds()).slice(-2);
    }
    function updateClock() {
      var label = document.getElementById('clockLabel');
      var btn = document.getElementById('clockSwitchBtn');
      if (clockMode === "bj") {
        label.textContent = "åŒ—äº¬æ—¶é—´: " + formatTime(getBJTime());
        btn.textContent = "åˆ‡æ¢ä¸ºæœ¬åœ°æ—¶é—´";
      } else {
        label.textContent = "æœ¬åœ°æ—¶é—´: " + formatTime(new Date());
        btn.textContent = "åˆ‡æ¢ä¸ºåŒ—äº¬æ—¶é—´";
      }
    }
    function switchClockMode() {
      clockMode = (clockMode === "bj") ? "local" : "bj";
      updateClock();
    }
    setInterval(updateClock, 1000);
    updateClock();

    // ç»çº¬åº¦è·ç¦»
    function haversine(lat1, lon1, lat2, lon2) {
      function toRad(x) { return x * Math.PI / 180; }
      var R = 6371;
      var dLat = toRad(lat2 - lat1);
      var dLon = toRad(lon2 - lon1);
      var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      var d = R * c;
      return d;
    }
    
    function getIntensityIcon(intensity) {
      if (!intensity) return "ğŸŸ¦";
      if (typeof intensity === 'number') {
        if (intensity >= 7) return "ğŸŸ¥";
        if (intensity >= 5) return "ğŸŸ§";
        if (intensity >= 3) return "ğŸŸ¨";
        return "ğŸŸ©";
      }
      if (/6|7/.test(intensity)) return "ğŸŸ¥";
      if (/5/.test(intensity)) return "ğŸŸ§";
      if (/4/.test(intensity)) return "ğŸŸ¨";
      if (/1|2|3/.test(intensity)) return "ğŸŸ©";
      return "ğŸŸ¦";
    }
    
    function getIntensityColor(intensity) {
      if (!intensity) return "#3498db";
      if (typeof intensity === 'number') {
        if (intensity >= 7) return "#e74c3c";
        if (intensity >= 5) return "#f39c12";
        if (intensity >= 3) return "#f1c40f";
        return "#2ecc71";
      }
      if (/6|7/.test(intensity)) return "#e74c3c";
      if (/5/.test(intensity)) return "#f39c12";
      if (/4/.test(intensity)) return "#f1c40f";
      if (/1|2|3/.test(intensity)) return "#2ecc71";
      return "#3498db";
    }
    
    function getSourceName(source) {
      const sourceNames = {
        cenc: "ä¸­å›½åœ°éœ‡å°ç½‘",
        usgs: "USGSå…¨çƒåœ°éœ‡",
        emsc: "EMSCå…¨çƒåœ°éœ‡",
        p2pquake: "P2PQuake",
        jma: "æ—¥æœ¬æ°”è±¡å…"
      };
      return sourceNames[source] || source;
    }

    var lat = parseFloat(localStorage.getItem('lat')) || 32;
    var lon = parseFloat(localStorage.getItem('lon')) || 110;
    document.getElementById('lat').value = lat;
    document.getElementById('lon').value = lon;

    var mapLoaded = false;
    var mapLoadingDiv = document.getElementById('mapLoading');
    var map = L.map('map').setView([lat, lon], 4);

    // åœ°å›¾å›¾å±‚
    var osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 18,
      attribution: 'Â© OpenStreetMap contributors'
    });
    
    var gaodeLayer = L.tileLayer('https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}', {
      subdomains: ['1','2','3','4'],
      maxZoom: 18,
      attribution: 'Â© é«˜å¾·åœ°å›¾'
    });
    
    var satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      maxZoom: 18,
      attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
    });

    // é»˜è®¤ä½¿ç”¨é«˜å¾·åœ°å›¾
    gaodeLayer.addTo(map);

    function switchMapStyle(style) {
      if (style === 'osm') {
        map.removeLayer(gaodeLayer);
        map.removeLayer(satelliteLayer);
        osmLayer.addTo(map);
      } else if (style === 'gaode') {
        map.removeLayer(osmLayer);
        map.removeLayer(satelliteLayer);
        gaodeLayer.addTo(map);
      } else if (style === 'satellite') {
        map.removeLayer(osmLayer);
        map.removeLayer(gaodeLayer);
        satelliteLayer.addTo(map);
      }
    }

    map.on('load', function() {
      mapLoaded = true;
      mapLoadingDiv.style.opacity = 0;
      setTimeout(()=>{mapLoadingDiv.style.display='none';},400);
    });
    map.on('loading', function() {
      mapLoadingDiv.style.opacity = 1;
      mapLoadingDiv.style.display = 'block';
    });

    var userMarker = L.marker([lat, lon], {title: "ä½ çš„ä½ç½®"}).addTo(map);
    var quakeMarkers = [];
    var lastMaxQuakeTime = '';
    var filteredQuakes = [];

    // åœ°éœ‡å›æ”¾ç›¸å…³å˜é‡
    var isReplayMode = false;
    var replayInterval = null;
    var currentReplayIndex = 0;
    var replayQuakes = [];
    var replayMarkers = [];

    function savePos() {
      var newLat = parseFloat(document.getElementById('lat').value);
      var newLon = parseFloat(document.getElementById('lon').value);
      localStorage.setItem('lat', newLat);
      localStorage.setItem('lon', newLon);
      userMarker.setLatLng([newLat, newLon]);
      map.setView([newLat, newLon], 4);
      document.getElementById('saved').innerText = "å·²ä¿å­˜ï¼";
      setTimeout(()=>{document.getElementById('saved').innerText=''},1500);
      fetchQuakeData();
    }

    const API_URLS = {
      cenc: "https://api.ceic.ac.cn/earthquake?limit=50",
      usgs: "https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson",
      emsc: "https://www.seismicportal.eu/fdsnws/event/1/query?format=json&limit=50",
      p2pquake: "https://api.p2pquake.net/v2/history?codes=551&limit=50",
      jma: "https://www.data.jma.go.jp/developer/xml/feed/eqvol_l.xml"
    };

    let quakeHistory = [];

    async function fetchQuakeData() {
      document.getElementById('status').innerText = "æ•°æ®åŠ è½½ä¸­...";
      const source = document.getElementById('sourceSelect').value;
      let quakes = [];
      quakeMarkers.forEach(m => map.removeLayer(m));
      quakeMarkers = [];
      try {
        if (source === "all") {
          const results = await Promise.allSettled([
            fetch(API_URLS.cenc).then(r => r.json()),
            fetch(API_URLS.usgs).then(r => r.json()),
            fetch(API_URLS.emsc).then(r => r.json()),
            fetch(API_URLS.p2pquake).then(r => r.json()),
            fetch(API_URLS.jma).then(r => r.text())
          ]);
          
          if (results[0].status === 'fulfilled' && results[0].value) 
            quakes = quakes.concat(parseCENC(results[0].value));
          if (results[1].status === 'fulfilled' && results[1].value) 
            quakes = quakes.concat(parseUSGS(results[1].value));
          if (results[2].status === 'fulfilled' && results[2].value) 
            quakes = quakes.concat(parseEMSC(results[2].value));
          if (results[3].status === 'fulfilled' && results[3].value) 
            quakes = quakes.concat(parseP2PQuake(results[3].value));
          if (results[4].status === 'fulfilled' && results[4].value) 
            quakes = quakes.concat(parseJMA(results[4].value));
        } else if (API_URLS[source]) {
          if (source === "jma") {
            const res = await fetch(API_URLS[source]);
            const text = await res.text();
            if (text) quakes = parseJMA(text);
          } else {
            const res = await fetch(API_URLS[source]);
            const data = await res.json();
            if (data) {
              if (source === "cenc") quakes = parseCENC(data);
              else if (source === "usgs") quakes = parseUSGS(data);
              else if (source === "emsc") quakes = parseEMSC(data);
              else if (source === "p2pquake") quakes = parseP2PQuake(data);
            }
          }
        } else {
          quakes = [];
        }
      } catch(e) {
        console.error("è·å–åœ°éœ‡æ•°æ®å¤±è´¥:", e);
        quakes = [];
      }
      
      // è¿‡æ»¤æ‰æ— æ•ˆæ•°æ®
      quakes = quakes.filter(q => q.mag && q.time);
      
      // æŒ‰æ—¶é—´æ’åº
      quakes.sort((a, b) => new Date(a.time) - new Date(b.time));
      quakeHistory = quakes.slice(0, 50);
      applyFilters();
      document.getElementById('status').innerText = "æ•°æ®å·²æ›´æ–° " + new Date().toLocaleTimeString();
    }

    function parseCENC(data) {
      if (!data || !data.earthquakes) return [];
      return data.earthquakes.map(e => ({
        mag: e.magnitude || 0,
        lat: e.latitude || 0,
        lon: e.longitude || 0,
        place: e.location || "æœªçŸ¥åœ°ç‚¹",
        time: e.time || new Date().toISOString(),
        intensity: e.intensity || "",
        dist: "",
        source: "cenc"
      }));
    }
    
    function parseUSGS(data) {
      if (!data || !data.features) return [];
      return data.features.map(f => ({
        mag: f.properties.mag || 0,
        lat: f.geometry.coordinates[1] || 0,
        lon: f.geometry.coordinates[0] || 0,
        place: f.properties.place || "æœªçŸ¥åœ°ç‚¹",
        time: new Date(f.properties.time).toISOString(),
        intensity: "",
        dist: "",
        source: "usgs"
      }));
    }
    
    function parseEMSC(data) {
      if (!data || !data.events) return [];
      return data.events.map(e => ({
        mag: e.magnitude?.value || 0,
        lat: e.latitude || 0,
        lon: e.longitude || 0,
        place: e.region || "æœªçŸ¥åœ°ç‚¹",
        time: e.time ? new Date(e.time).toISOString() : new Date().toISOString(),
        intensity: "",
        dist: "",
        source: "emsc"
      }));
    }
    
    function parseP2PQuake(data) {
      if (!data || !Array.isArray(data)) return [];
      return data.map(e => ({
        mag: e.earthquake?.hypocenter?.magnitude || 0,
        lat: e.earthquake?.hypocenter?.latitude || 0,
        lon: e.earthquake?.hypocenter?.longitude || 0,
        place: e.earthquake?.hypocenter?.name || "æœªçŸ¥åœ°ç‚¹",
        time: e.earthquake?.time ? new Date(e.earthquake.time).toISOString() : new Date().toISOString(),
        intensity: e.earthquake?.maxScale || "",
        dist: "",
        source: "p2pquake"
      }));
    }
    
    function parseJMA(xmltext) {
      try {
        let parser = new DOMParser();
        let xml = parser.parseFromString(xmltext, "application/xml");
        let items = xml.getElementsByTagName("item");
        let result = [];
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          let title = item.getElementsByTagName("title")[0]?.textContent || "";
          let pubDate = item.getElementsByTagName("pubDate")[0]?.textContent || "";
          let description = item.getElementsByTagName("description")[0]?.textContent || "";
          let mag = /ï¼­([0-9.]+)/.exec(description)?.[1] || "0";
          let epicenter = /éœ‡æºåœ°ï¼š([^ï¼ˆ\s]+)/.exec(description)?.[1] || title.replace(/ã€.*?ã€‘/,"").replace(/.*åœ°éœ‡æƒ…å ±\s*/,"").trim();
          result.push({
            mag: mag,
            lat: null,
            lon: null,
            place: epicenter || "æœªçŸ¥åœ°ç‚¹",
            time: pubDate || new Date().toISOString(),
            intensity: "",
            dist: "",
            source: "jma"
          });
        }
        return result;
      } catch(e) {
        console.error("è§£æJMAæ•°æ®å¤±è´¥:", e);
        return [];
      }
    }

    function applyFilters() {
      const minMag = parseFloat(document.getElementById('minMag').value) || 0;
      const maxDist = parseFloat(document.getElementById('maxDist').value) || 10000;
      const timeRange = parseFloat(document.getElementById('timeRange').value) || 24;
      
      const userLat = parseFloat(document.getElementById('lat').value);
      const userLon = parseFloat(document.getElementById('lon').value);
      const now = new Date();
      const timeThreshold = new Date(now.getTime() - timeRange * 60 * 60 * 1000);
      
      filteredQuakes = quakeHistory.filter(q => {
        // éœ‡çº§ç­›é€‰
        if (parseFloat(q.mag) < minMag) return false;
        
        // æ—¶é—´ç­›é€‰
        const quakeTime = new Date(q.time);
        if (quakeTime < timeThreshold) return false;
        
        // è·ç¦»ç­›é€‰
        if (q.lat && q.lon) {
          const dist = haversine(userLat, userLon, q.lat, q.lon);
          if (dist > maxDist) return false;
        }
        
        return true;
      });
      
      renderList(filteredQuakes);
      addQuakeMarkers(filteredQuakes);
      renderTimeline(filteredQuakes);
      triggerAlert(filteredQuakes);
    }

    function renderList(quakes) {
      var userLat = parseFloat(document.getElementById('lat').value);
      var userLon = parseFloat(document.getElementById('lon').value);
      var list = document.getElementById('list');
      if (!quakes || quakes.length === 0) {
        list.innerHTML = "<div>æš‚æ— åœ°éœ‡æ•°æ®</div>";
        return;
      }
      
      list.innerHTML = quakes.map((q, index) => {
        let dist = (q.lat && q.lon) ? haversine(userLat, userLon, q.lat, q.lon) : null;
        let pWave = dist ? (dist / 6).toFixed(1) : "?";
        let sWave = dist ? (dist / 3.5).toFixed(1) : "?";
        let intensityIcon = getIntensityIcon(q.intensity);
        let intensityColor = getIntensityColor(q.intensity);
        let intensityText = q.intensity
          ? `çƒˆåº¦/éœ‡åº¦ï¼š${q.intensity}`
          : "çƒˆåº¦/éœ‡åº¦ï¼šæœªçŸ¥";
          
        return `<div class="item" onclick="showQuakeDetails(${index})" style="border-left-color: ${intensityColor}">
          <span class="icon">${intensityIcon}</span>
          <span class="mag">M${q.mag}</span>
          <span class="dist">${dist ? dist.toFixed(1)+'km' : 'æœªçŸ¥è·ç¦»'}</span>
          <span class="intensity">${intensityText}</span>
          <div style="margin-left:34px">
            <span>${q.place}</span>
            <span class="source-badge">${getSourceName(q.source)}</span>
          </div>
          <div style="margin-left:34px; font-size: 12px; color: #666;">
            <span class="quake-time">${new Date(q.time).toLocaleString()}</span>
          </div>
        </div>`;
      }).join('');
    }

    function showQuakeDetails(index) {
      const q = filteredQuakes[index];
      const userLat = parseFloat(document.getElementById('lat').value);
      const userLon = parseFloat(document.getElementById('lon').value);
      const dist = (q.lat && q.lon) ? haversine(userLat, userLon, q.lat, q.lon) : null;
      const pWave = dist ? (dist / 6).toFixed(1) : "?";
      const sWave = dist ? (dist / 3.5).toFixed(1) : "?";
      
      document.getElementById('detailPlace').textContent = q.place;
      document.getElementById('detailMag').textContent = `M${q.mag}`;
      document.getElementById('detailTime').textContent = new Date(q.time).toLocaleString();
      document.getElementById('detailIntensity').textContent = q.intensity || "æœªçŸ¥";
      document.getElementById('detailDistance').textContent = dist ? `${dist.toFixed(1)} km` : "æœªçŸ¥";
      document.getElementById('detailPWave').textContent = `${pWave} ç§’`;
      document.getElementById('detailSWave').textContent = `${sWave} ç§’`;
      document.getElementById('detailSource').textContent = getSourceName(q.source);
      
      document.getElementById('quakeDetails').style.display = 'block';
      
      // å¤åˆ¶ä¿¡æ¯åˆ°å‰ªè´´æ¿
      copyToClipboard(`${q.place} | M${q.mag} | ${new Date(q.time).toLocaleString()} | çƒˆåº¦/éœ‡åº¦: ${q.intensity || "æœªçŸ¥"} | æ•°æ®æº: ${getSourceName(q.source)}`);
    }

    function addQuakeMarkers(quakes) {
      quakeMarkers.forEach(m => map.removeLayer(m));
      quakeMarkers = [];
      var userLat = parseFloat(document.getElementById('lat').value);
      var userLon = parseFloat(document.getElementById('lon').value);
      quakes.forEach(q => {
        if (q.lat && q.lon) {
          let dist = haversine(userLat, userLon, q.lat, q.lon);
          let pWave = (dist / 6).toFixed(1);
          let sWave = (dist / 3.5).toFixed(1);
          let intensityIcon = getIntensityIcon(q.intensity);
          let color = getIntensityColor(q.intensity);
          
          let marker = L.circleMarker([q.lat, q.lon], {
            radius: Math.max(4, q.mag * 2),
            color: color,
            fillOpacity: 0.7
          }).addTo(map);
          
          marker.bindPopup(
            `<b>${intensityIcon} çƒˆåº¦/éœ‡åº¦</b>: ${q.intensity || "æœªçŸ¥"}<br>
             <b>åœ°å</b>: ${q.place}<br>
             <b>æ—¶é—´</b>: ${new Date(q.time).toLocaleString()}<br>
             <b>éœ‡çº§</b>: M${q.mag}<br>
             <b>è·ç¦»ä½ </b>: ${dist.toFixed(1)}km<br>
             <b>Pæ³¢åˆ°è¾¾</b>: ${pWave}ç§’<br>
             <b>Sæ³¢åˆ°è¾¾</b>: ${sWave}ç§’<br>
             <b>æ•°æ®æº</b>: ${getSourceName(q.source)}`
          );
          quakeMarkers.push(marker);
        }
      });
    }

    function renderTimeline(quakes) {
      const timeline = document.getElementById('timeline');
      timeline.innerHTML = '';
      
      if (!quakes || quakes.length === 0) return;
      
      // è·å–æ—¶é—´èŒƒå›´
      const times = quakes.map(q => new Date(q.time).getTime());
      const minTime = Math.min(...times);
      const maxTime = Math.max(...times);
      const timeRange = maxTime - minTime;
      
      // åœ¨æ—¶é—´çº¿ä¸Šæ·»åŠ æ ‡è®°
      quakes.forEach((q, index) => {
        const quakeTime = new Date(q.time).getTime();
        const position = ((quakeTime - minTime) / timeRange) * 100;
        
        const marker = document.createElement('div');
        marker.className = 'timeline-marker';
        marker.style.left = `${position}%`;
        marker.style.backgroundColor = getIntensityColor(q.intensity);
        marker.title = `${q.place} - M${q.mag}`;
        marker.onclick = () => showQuakeDetails(index);
        
        const label = document.createElement('div');
        label.className = 'timeline-label';
        label.style.left = `${position}%`;
        label.textContent = `M${q.mag}`;
        
  
