<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <title>haGQ</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    body{margin:0;font-family:Arial;background:#f2f2f2;display:flex;height:100vh;}
    #map{flex:1;height:100%;position:relative;}
    #sidebar{width:350px;background:#fff;box-shadow:-2px 0 5px rgba(0,0,0,.1);padding:10px;overflow-y:auto;}
    .item{background:#f7f7f7;margin:6px 0;padding:8px;border-radius:4px;cursor:pointer;display:flex;align-items:center;}
    .mag{font-weight:bold;font-size:18px;margin-right:8px;}
    .dist{color:#666;margin-left:10px;}
    .intensity{margin-left:10px;font-size:16px;font-weight:bold;}
    .icon{width:28px;height:28px;display:inline-block;}
    .setting{background:#e9e9e9;padding:10px;border-radius:6px;margin-bottom:10px;}
    label{margin-right:10px;}input{width:120px;}
    #status{font-size:14px;color:#555;margin-left:10px;}
    audio{display:none;}
    #mapLoading {
      position:absolute;top:10px;left:10px;background:rgba(0,0,0,.35);
      color:#fff;font-size:18px;font-weight:bold;padding:6px 22px;border-radius:8px;z-index:1000;
      box-shadow:0 2px 8px rgba(0,0,0,.10);pointer-events:none;
      transition:opacity .3s;
    }
    #mapClock {
      position:absolute;right:10px;bottom:10px;background:rgba(255,255,255,0.85);
      font-size:16px;padding:6px 18px;border-radius:8px;border:1px solid #d9d9d9;z-index:1200;
      box-shadow:0 2px 8px rgba(0,0,0,.07);
      display:flex;align-items:center;
    }
    #clockSwitchBtn {
      margin-left:12px;background:#eee;border-radius:5px;border:1px solid #ccc;
      font-size:14px;padding:1px 8px;cursor:pointer;
      transition:background .2s;
    }
    #clockSwitchBtn:hover {background:#d7eaff;}
  </style>
</head>
<body>
  <div id="map">
    <div id="mapLoading">æœªåŠ è½½å®Œæˆ</div>
    <div id="mapClock">
      <span id="clockLabel"></span>
      <button id="clockSwitchBtn" onclick="switchClockMode()">åˆ‡æ¢ä¸ºæœ¬åœ°æ—¶é—´</button>
    </div>
  </div>
  <div id="sidebar">
    <h1>haGQ
      <span id="status"></span>
    </h1>
    <div class="setting">
      <label>çº¬åº¦ï¼š<input id="lat" type="number" step="0.0001" value="32"></label>
      <label>ç»åº¦ï¼š<input id="lon" type="number" step="0.0001" value="110"></label>
      <button onclick="savePos()">ä¿å­˜</button>
      <span id="saved"></span>
      <br>
      <label>æ•°æ®æºï¼š</label>
      <select id="sourceSelect" onchange="fetchQuakeData()">
        <option value="source1">ä¸­å›½åœ°éœ‡é€ŸæŠ¥</option>
        <option value="source2">USGSå…¨çƒåœ°éœ‡</option>
        <option value="source3">EMSCå…¨çƒåœ°éœ‡</option>
        <option value="source5">é¦™æ¸¯åœ°éœ‡å°</option>
        <option value="all">å…¨éƒ¨æ•°æ®æº</option>
      </select>
    </div>
    <div class="copy-info" id="copyInfo">å¯ç‚¹å‡»å†å²åœ°éœ‡é¡¹å¤åˆ¶ä¿¡æ¯</div>
    <h3 id="listTitle">å†å²åœ°éœ‡ï¼ˆæœ€è¿‘50æ¡ï¼‰</h3>
    <div id="list"></div>
  </div>
  <audio id="alert" src="data:audio/wav;base64,UklGRoABAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8A" preload="auto"></audio>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // æ—¶é’Ÿç›¸å…³
    var clockMode = "bj";
    function getBJTime() {
      let now = new Date();
      let bj = new Date(now.getTime() + (8 - now.getTimezoneOffset()/60)*3600*1000 - now.getTimezoneOffset()*60*1000);
      return bj;
    }
    function formatTime(dt) {
      return dt.getFullYear() + '-' + ('0'+(dt.getMonth()+1)).slice(-2) + '-' +
        ('0'+dt.getDate()).slice(-2) + ' ' + ('0'+dt.getHours()).slice(-2) + ':' +
        ('0'+dt.getMinutes()).slice(-2) + ':' + ('0'+dt.getSeconds()).slice(-2);
    }
    function updateClock() {
      var label = document.getElementById('clockLabel');
      var btn = document.getElementById('clockSwitchBtn');
      if (clockMode === "bj") {
        label.textContent = "åŒ—äº¬æ—¶é—´: " + formatTime(getBJTime());
        btn.textContent = "åˆ‡æ¢ä¸ºæœ¬åœ°æ—¶é—´";
      } else {
        label.textContent = "æœ¬åœ°æ—¶é—´: " + formatTime(new Date());
        btn.textContent = "åˆ‡æ¢ä¸ºåŒ—äº¬æ—¶é—´";
      }
    }
    function switchClockMode() {
      clockMode = (clockMode === "bj") ? "local" : "bj";
      updateClock();
    }
    setInterval(updateClock, 1000);
    updateClock();

    // ç»çº¬åº¦è·ç¦»
    function haversine(lat1, lon1, lat2, lon2) {
      function toRad(x) { return x * Math.PI / 180; }
      var R = 6371;
      var dLat = toRad(lat2 - lat1);
      var dLon = toRad(lon2 - lon1);
      var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      var d = R * c;
      return d;
    }
    function getIntensityIcon(intensity) {
      if (!intensity) return "ğŸŸ¦";
      if (typeof intensity === 'number') {
        if (intensity >= 7) return "ğŸŸ¥";
        if (intensity >= 5) return "ğŸŸ§";
        if (intensity >= 3) return "ğŸŸ¨";
        return "ğŸŸ©";
      }
      if (/6|7/.test(intensity)) return "ğŸŸ¥";
      if (/5/.test(intensity)) return "ğŸŸ§";
      if (/4/.test(intensity)) return "ğŸŸ¨";
      if (/1|2|3/.test(intensity)) return "ğŸŸ©";
      return "ğŸŸ¦";
    }

    var lat = parseFloat(localStorage.getItem('lat')) || 32;
    var lon = parseFloat(localStorage.getItem('lon')) || 110;
    document.getElementById('lat').value = lat;
    document.getElementById('lon').value = lon;

    var mapLoaded = false;
    var mapLoadingDiv = document.getElementById('mapLoading');
    var map = L.map('map').setView([lat, lon], 4);

    // é«˜å¾·ç®€çº¦å…¨çƒè·¯ç½‘åº•å›¾ style=8
    L.tileLayer('https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}', {
      subdomains: ['1','2','3','4'],
      maxZoom: 18,
      attribution: 'Â© é«˜å¾·åœ°å›¾'
    }).addTo(map);

    map.on('load', function() {
      mapLoaded = true;
      mapLoadingDiv.style.opacity = 0;
      setTimeout(()=>{mapLoadingDiv.style.display='none';},400);
    });
    map.on('loading', function() {
      mapLoadingDiv.style.opacity = 1;
      mapLoadingDiv.style.display = 'block';
    });

    var userMarker = L.marker([lat, lon], {title: "ä½ çš„ä½ç½®"}).addTo(map);
    var quakeMarkers = [];
    var lastMaxQuakeTime = '';

    function savePos() {
      var newLat = parseFloat(document.getElementById('lat').value);
      var newLon = parseFloat(document.getElementById('lon').value);
      localStorage.setItem('lat', newLat);
      localStorage.setItem('lon', newLon);
      userMarker.setLatLng([newLat, newLon]);
      map.setView([newLat, newLon], 4);
      document.getElementById('saved').innerText = "å·²ä¿å­˜ï¼";
      setTimeout(()=>{document.getElementById('saved').innerText=''},1500);
      fetchQuakeData();
    }

    const API_URLS = {
      source1: "https://api.ceic.ac.cn/earthquake?limit=50", // ä¸­å›½åœ°éœ‡å°ç½‘
      source2: "https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson", // USGS
      source3: "https://www.seismicportal.eu/fdsnws/event/1/query?format=json&limit=50", // EMSC
      source5: "https://data.weather.gov.hk/weatherAPI/opendata/earthquake.php?dataType=rss&lang=tc" // é¦™æ¸¯åœ°éœ‡å°
    };

    let quakeHistory = [];

    async function fetchQuakeData() {
      document.getElementById('status').innerText = "æ•°æ®åŠ è½½ä¸­...";
      const source = document.getElementById('sourceSelect').value;
      let quakes = [];
      quakeMarkers.forEach(m => map.removeLayer(m));
      quakeMarkers = [];
      try {
        if (source === "all") {
          const results = await Promise.all([
            fetch(API_URLS.source1).then(r => r.json()).catch(()=>null),
            fetch(API_URLS.source2).then(r => r.json()).catch(()=>null),
            fetch(API_URLS.source3).then(r => r.json()).catch(()=>null),
            fetch(API_URLS.source5).then(r => r.text()).catch(()=>null)
          ]);
          if (results[0]) quakes = quakes.concat(parseSource1(results[0]));
          if (results[1]) quakes = quakes.concat(parseSource2(results[1]));
          if (results[2]) quakes = quakes.concat(parseSource3(results[2]));
          if (results[3]) quakes = quakes.concat(parseSource5(results[3]));
        } else if (API_URLS[source]) {
          if (source === "source5") {
            const res = await fetch(API_URLS[source]).then(r => r.text()).catch(()=>null);
            if (res) quakes = parseSource5(res);
          } else {
            const res = await fetch(API_URLS[source]).then(r => r.json()).catch(()=>null);
            if (res) {
              if (source === "source1") quakes = parseSource1(res);
              else if (source === "source2") quakes = parseSource2(res);
              else if (source === "source3") quakes = parseSource3(res);
            }
          }
        } else {
          quakes = [];
        }
      } catch(e) {
        quakes = [];
      }
      quakes.sort((a, b) => new Date(a.time) - new Date(b.time));
      quakeHistory = quakes.slice(0, 50);
      renderList(quakeHistory);
      addQuakeMarkers(quakeHistory);
      document.getElementById('status').innerText = "å®æ—¶æ›´æ–°ä¸­";
      triggerAlert(quakeHistory);
    }

    function parseSource1(data) {
      if (!data || !data.earthquakes) return [];
      return data.earthquakes.map(e => ({
        mag: e.magnitude,
        lat: e.latitude,
        lon: e.longitude,
        place: e.location || "",
        time: e.time || "",
        intensity: "",
        dist: (e.distance || "") + "km"
      }));
    }
    function parseSource2(data) {
      if (!data || !data.features) return [];
      return data.features.map(f => ({
        mag: f.properties.mag,
        lat: f.geometry.coordinates[1],
        lon: f.geometry.coordinates[0],
        place: f.properties.place,
        time: new Date(f.properties.time).toLocaleString(),
        intensity: "",
        dist: ""
      }));
    }
    function parseSource3(data) {
      if (!data || !data.events) return [];
      return data.events.map(e => ({
        mag: e.magnitude.value,
        lat: e.latitude,
        lon: e.longitude,
        place: e.region || "",
        time: e.time ? new Date(e.time).toLocaleString() : "",
        intensity: "",
        dist: ""
      }));
    }
    function parseSource5(xmltext) {
      let parser = new DOMParser();
      let xml = parser.parseFromString(xmltext, "application/xml");
      let items = xml.getElementsByTagName("item");
      let result = [];
      for (let i = 0; i < items.length; i++) {
        let item = items[i];
        let title = item.getElementsByTagName("title")[0]?.textContent || "";
        let pubDate = item.getElementsByTagName("pubDate")[0]?.textContent || "";
        let description = item.getElementsByTagName("description")[0]?.textContent || "";
        let mag = /éœ‡çº§[:ï¼š]\s*([0-9.]+)/.exec(description)?.[1] || "";
        let lat = /çº¬åº¦[:ï¼š]\s*([0-9.]+)/.exec(description)?.[1] || null;
        let lon = /ç»åº¦[:ï¼š]\s*([0-9.]+)/.exec(description)?.[1] || null;
        let epicenter = /éœ‡ä¸­ä½ç½®[:ï¼š]\s*([^\s]+)/.exec(description)?.[1] || "";
        let intensity = /çƒˆåº¦[:ï¼š]\s*([^\s]+)/.exec(description)?.[1] || "";
        result.push({
          mag: mag,
          lat: lat ? parseFloat(lat) : null,
          lon: lon ? parseFloat(lon) : null,
          place: epicenter || title,
          time: pubDate,
          intensity: intensity,
          dist: ""
        });
      }
      return result;
    }

    function renderList(quakes) {
      var userLat = parseFloat(document.getElementById('lat').value);
      var userLon = parseFloat(document.getElementById('lon').value);
      var list = document.getElementById('list');
      if (!quakes || quakes.length === 0) {
        list.innerHTML = "<div>æš‚æ— åœ°éœ‡æ•°æ®</div>";
        return;
      }
      list.innerHTML = quakes.map(q => {
        let dist = (q.lat && q.lon) ? haversine(userLat, userLon, q.lat, q.lon) : null;
        let pWave = dist ? (dist / 6).toFixed(1) : "?";
        let sWave = dist ? (dist / 3.5).toFixed(1) : "?";
        let intensityIcon = getIntensityIcon(q.intensity);
        let intensityText = q.intensity
          ? `çƒˆåº¦/éœ‡åº¦ï¼š${q.intensity}`
          : "çƒˆåº¦/éœ‡åº¦ï¼šæœªçŸ¥ï¼ˆæ•°æ®æºæ— çƒˆåº¦å­—æ®µï¼‰";
        return `<div class="item" onclick="copyToClipboard('${q.place} | M${q.mag} | ${q.time} | ${intensityText}')">
          <span class="icon">${intensityIcon}</span>
          <span class="mag">M${q.mag}</span>
          <span class="dist">éœ‡ä¸­è·ç¦»:${dist ? dist.toFixed(1)+'km' : 'æœªçŸ¥'}</span>
          <span class="intensity">${intensityText}</span>
          <div style="margin-left:34px">${q.place} | ${q.time}</div>
          <div style="margin-left:34px">Pæ³¢åˆ°è¾¾ï¼š${pWave} ç§’ï¼ŒSæ³¢åˆ°è¾¾ï¼š${sWave} ç§’</div>
        </div>`;
      }).join('');
    }

    function addQuakeMarkers(quakes) {
      quakeMarkers.forEach(m => map.removeLayer(m));
      quakeMarkers = [];
      var userLat = parseFloat(document.getElementById('lat').value);
      var userLon = parseFloat(document.getElementById('lon').value);
      quakes.forEach(q => {
        if (q.lat && q.lon) {
          let dist = haversine(userLat, userLon, q.lat, q.lon);
          let pWave = (dist / 6).toFixed(1);
          let sWave = (dist / 3.5).toFixed(1);
          let intensityIcon = getIntensityIcon(q.intensity);
          let color =
            intensityIcon === "ğŸŸ¥" ? "red" :
            intensityIcon === "ğŸŸ§" ? "orange" :
            intensityIcon === "ğŸŸ¨" ? "yellow" :
            intensityIcon === "ğŸŸ©" ? "green" : "blue";
          let marker = L.circleMarker([q.lat, q.lon], {
            radius: Math.max(4, q.mag * 2),
            color: color,
            fillOpacity: 0.7
          }).addTo(map);
          marker.bindPopup(
            `<b>${intensityIcon} çƒˆåº¦/éœ‡åº¦</b>: ${q.intensity || "æœªçŸ¥ï¼ˆæ•°æ®æºæ— çƒˆåº¦å­—æ®µï¼‰"}<br>
             <b>åœ°å</b>: ${q.place}<br>
             <b>æ—¶é—´</b>: ${q.time}<br>
             <b>éœ‡çº§</b>: M${q.mag}<br>
             <b>è·ç¦»ä½ </b>: ${dist.toFixed(1)}km<br>
             <b>Pæ³¢åˆ°è¾¾</b>: ${pWave}ç§’<br>
             <b>Sæ³¢åˆ°è¾¾</b>: ${sWave}ç§’`
          );
          quakeMarkers.push(marker);
        }
      });
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text);
      document.getElementById('copyInfo').innerText = "å·²å¤åˆ¶ï¼š" + text;
      setTimeout(()=>{document.getElementById('copyInfo').innerText="å¯ç‚¹å‡»å†å²åœ°éœ‡é¡¹å¤åˆ¶ä¿¡æ¯";},1500);
    }

    function triggerAlert(quakes) {
      if (!quakes || quakes.length === 0) return;
      let maxQuake = quakes[quakes.length-1];
      let mag = parseFloat(maxQuake.mag);
      let dist = (maxQuake.lat && maxQuake.lon) ? haversine(
        parseFloat(document.getElementById('lat').value),
        parseFloat(document.getElementById('lon').value),
        maxQuake.lat,
        maxQuake.lon
      ) : null;
      let intensity = maxQuake.intensity || "";
      let shouldAlert = (mag >= 5 && dist !== null && dist <= 200)
        || (/6å¼º|7/.test(intensity));
      if (shouldAlert) {
        if (lastMaxQuakeTime !== maxQuake.time) {
          lastMaxQuakeTime = maxQuake.time;
          var audio = document.getElementById('alert');
          audio.currentTime = 0;
          audio.play();
        }
      }
    }

    fetchQuakeData();
    setInterval(fetchQuakeData, 60 * 1000);
  </script>
</body>
</html>
