<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <title>haGQ - å…¨çƒåœ°éœ‡ç›‘æµ‹</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root {
      --primary-color: #3498db;
      --danger-color: #e74c3c;
      --warning-color: #f39c12;
      --success-color: #2ecc71;
      --light-color: #ecf0f1;
      --dark-color: #2c3e50;
    }
    
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #f2f2f2;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    
    #map {
      flex: 1;
      height: 100%;
      position: relative;
    }
    
    #sidebar {
      width: 420px;
      background: #fff;
      box-shadow: -2px 0 5px rgba(0,0,0,.1);
      padding: 15px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }
    
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }
    
    .header h1 {
      margin: 0;
      color: var(--dark-color);
      font-size: 24px;
    }
    
    .item {
      background: #f7f7f7;
      margin: 8px 0;
      padding: 12px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      transition: all 0.2s;
      border-left: 4px solid #3498db;
    }
    
    .item:hover {
      background: #e9f7fe;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .mag {
      font-weight: bold;
      font-size: 18px;
      margin-right: 8px;
      min-width: 50px;
    }
    
    .dist {
      color: #666;
      margin-left: 10px;
      font-size: 14px;
    }
    
    .intensity {
      margin-left: 10px;
      font-size: 14px;
      font-weight: bold;
    }
    
    .icon {
      width: 28px;
      height: 28px;
      display: inline-block;
      margin-right: 10px;
    }
    
    .setting {
      background: #e9e9e9;
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 15px;
    }
    
    label {
      margin-right: 10px;
      font-weight: 500;
    }
    
    input, select {
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    
    input {
      width: 120px;
    }
    
    button {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    button:hover {
      background: #2980b9;
    }
    
    #status {
      font-size: 14px;
      color: #555;
      margin-left: 10px;
    }
    
    audio {
      display: none;
    }
    
    #mapLoading {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,.35);
      color: #fff;
      font-size: 18px;
      font-weight: bold;
      padding: 6px 22px;
      border-radius: 8px;
      z-index: 1000;
      box-shadow: 0 2px 8px rgba(0,0,0,.10);
      pointer-events: none;
      transition: opacity .3s;
    }
    
    #mapClock {
      position: absolute;
      right: 10px;
      bottom: 10px;
      background: rgba(255,255,255,0.85);
      font-size: 16px;
      padding: 6px 18px;
      border-radius: 8px;
      border: 1px solid #d9d9d9;
      z-index: 1200;
      box-shadow: 0 2px 8px rgba(0,0,0,.07);
      display: flex;
      align-items: center;
    }
    
    #clockSwitchBtn {
      margin-left: 12px;
      background: #eee;
      border-radius: 5px;
      border: 1px solid #ccc;
      font-size: 14px;
      padding: 1px 8px;
      cursor: pointer;
      transition: background .2s;
    }
    
    #clockSwitchBtn:hover {
      background: #d7eaff;
    }
    
    .copy-info {
      background: #e8f4fd;
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 10px;
      font-size: 14px;
      color: #2c3e50;
    }
    
    .filter-section {
      margin: 10px 0;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 6px;
    }
    
    .filter-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 8px;
    }
    
    .filter-controls label {
      display: flex;
      align-items: center;
      font-size: 14px;
    }
    
    .filter-controls input {
      width: 60px;
      margin-left: 5px;
    }
    
    .quake-details {
      display: none;
      background: white;
      padding: 15px;
      border-radius: 6px;
      margin-top: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .quake-details h4 {
      margin-top: 0;
      color: var(--dark-color);
    }
    
    .quake-details table {
      width: 100%;
      border-collapse: collapse;
    }
    
    .quake-details td {
      padding: 5px 0;
      border-bottom: 1px solid #eee;
    }
    
    .quake-details td:first-child {
      font-weight: bold;
      width: 40%;
    }
    
    .timeline-container {
      margin-top: 15px;
      background: white;
      padding: 15px;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    .timeline {
      height: 60px;
      position: relative;
      margin-top: 10px;
    }
    
    .timeline-marker {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      transform: translateX(-50%);
      cursor: pointer;
    }
    
    .timeline-label {
      position: absolute;
      top: 15px;
      font-size: 10px;
      transform: translateX(-50%);
      white-space: nowrap;
    }
    
    .source-badge {
      background: #e1f5fe;
      color: #01579b;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 12px;
      margin-left: 8px;
    }
    
    .quake-time {
      color: #666;
      font-size: 12px;
      margin-left: 8px;
    }
    
    .map-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: white;
      padding: 8px;
      border-radius: 4px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    
    .map-controls button {
      margin: 2px;
      padding: 4px 8px;
      font-size: 12px;
    }
    
    .alert-banner {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(231, 76, 60, 0.9);
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      z-index: 1000;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      display: none;
      font-weight: bold;
    }
    
    .replay-controls {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 15px;
      border-radius: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      display: none;
      align-items: center;
      gap: 10px;
    }
    
    .replay-controls button {
      padding: 4px 8px;
      font-size: 12px;
    }
    
    .replay-slider {
      width: 200px;
    }
    
    .replay-time {
      font-size: 14px;
      font-weight: bold;
      min-width: 150px;
      text-align: center;
    }
    
    .replay-speed {
      width: 80px;
    }
    
    .loading-dots:after {
      content: '...';
      animation: dots 1.5s steps(4, end) infinite;
    }
    
    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }
    
    .error-message {
      background: #ffebee;
      color: #c62828;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      border-left: 4px solid #c62828;
    }
    
    .retry-button {
      background: #c62828;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
      margin-left: 10px;
    }
    
    .performance-stats {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 1000;
    }
    
    @media (max-width: 768px) {
      body {
        flex-direction: column;
      }
      
      #sidebar {
        width: 100%;
        height: 40%;
      }
      
      #map {
        height: 60%;
      }
      
      .replay-controls {
        bottom: 10px;
        left: 10px;
        transform: none;
        flex-wrap: wrap;
        width: calc(100% - 20px);
      }
      
      .replay-slider {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div id="map">
    <div id="mapLoading">åœ°å›¾åŠ è½½ä¸­<span class="loading-dots"></span></div>
    <div id="mapClock">
      <span id="clockLabel"></span>
      <button id="clockSwitchBtn" onclick="switchClockMode()">åˆ‡æ¢ä¸ºæœ¬åœ°æ—¶é—´</button>
    </div>
    <div class="map-controls">
      <button onclick="switchMapStyle('osm')">ä¸–ç•Œåœ°å›¾</button>
      <button onclick="switchMapStyle('gaode')">é«˜å¾·åœ°å›¾</button>
      <button onclick="switchMapStyle('satellite')">å«æ˜Ÿåœ°å›¾</button>
      <button onclick="toggleReplay()" id="replayToggleBtn">åœ°éœ‡å›æ”¾</button>
    </div>
    <div class="alert-banner" id="alertBanner">
      <span id="alertText"></span>
      <button onclick="closeAlert()" style="margin-left: 10px; background: white; color: #e74c3c;">å…³é—­</button>
    </div>
    <div class="replay-controls" id="replayControls">
      <button onclick="replayFirst()" title="è·³åˆ°å¼€å§‹">â®</button>
      <button onclick="replayPrev()" title="ä¸Šä¸€æ­¥">â—€</button>
      <button onclick="toggleReplayPlay()" id="replayPlayBtn">â–¶</button>
      <button onclick="replayNext()" title="ä¸‹ä¸€æ­¥">â–¶</button>
      <button onclick="replayLast()" title="è·³åˆ°ç»“æŸ">â­</button>
      <input type="range" min="0" max="100" value="0" class="replay-slider" id="replaySlider">
      <span class="replay-time" id="replayTime">--</span>
      <select class="replay-speed" id="replaySpeed">
        <option value="5000">0.2x</option>
        <option value="2000" selected>0.5x</option>
        <option value="1000">1x</option>
        <option value="500">2x</option>
        <option value="250">4x</option>
      </select>
      <button onclick="toggleReplay()" style="background: #e74c3c;">å…³é—­å›æ”¾</button>
    </div>
    <div class="performance-stats" id="performanceStats">
      æ•°æ®: <span id="dataCount">0</span> | å†…å­˜: <span id="memoryUsage">0MB</span>
    </div>
  </div>
  <div id="sidebar">
    <div class="header">
      <h1>haGQ - å…¨çƒåœ°éœ‡ç›‘æµ‹</h1>
      <span id="status"></span>
    </div>
    
    <div class="setting">
      <label>çº¬åº¦ï¼š<input id="lat" type="number" step="0.0001" value="32"></label>
      <label>ç»åº¦ï¼š<input id="lon" type="number" step="0.0001" value="110"></label>
      <button onclick="savePos()">ä¿å­˜</button>
      <span id="saved"></span>
      <br>
      <label>æ•°æ®æºï¼š</label>
      <select id="sourceSelect" onchange="fetchQuakeData()">
        <option value="all">å…¨éƒ¨æ•°æ®æº</option>
        <option value="cenc">ä¸­å›½åœ°éœ‡å°ç½‘</option>
        <option value="usgs">USGSå…¨çƒåœ°éœ‡</option>
        <option value="emsc">EMSCå…¨çƒåœ°éœ‡</option>
        <option value="p2pquake">P2PQuake</option>
        <option value="jma">æ—¥æœ¬æ°”è±¡å…</option>
      </select>
    </div>
    
    <div class="filter-section">
      <strong>ç­›é€‰æ¡ä»¶ï¼š</strong>
      <div class="filter-controls">
        <label>æœ€å°éœ‡çº§ï¼š<input id="minMag" type="number" min="0" max="10" step="0.1" value="0" onchange="applyFilters()"></label>
        <label>æœ€å¤§è·ç¦»ï¼š<input id="maxDist" type="number" min="0" step="100" value="10000" onchange="applyFilters()"> km</label>
        <label>æ—¶é—´èŒƒå›´ï¼š<input id="timeRange" type="number" min="1" value="24" onchange="applyFilters()"> å°æ—¶</label>
      </div>
    </div>
    
    <div class="copy-info" id="copyInfo">å¯ç‚¹å‡»å†å²åœ°éœ‡é¡¹å¤åˆ¶ä¿¡æ¯</div>
    
    <div class="quake-details" id="quakeDetails">
      <h4>åœ°éœ‡è¯¦æƒ…</h4>
      <table>
        <tr><td>åœ°ç‚¹ï¼š</td><td id="detailPlace"></td></tr>
        <tr><td>éœ‡çº§ï¼š</td><td id="detailMag"></td></tr>
        <tr><td>æ—¶é—´ï¼š</td><td id="detailTime"></td></tr>
        <tr><td>çƒˆåº¦ï¼š</td><td id="detailIntensity"></td></tr>
        <tr><td>è·ç¦»ï¼š</td><td id="detailDistance"></td></tr>
        <tr><td>Pæ³¢åˆ°è¾¾ï¼š</td><td id="detailPWave"></td></tr>
        <tr><td>Sæ³¢åˆ°è¾¾ï¼š</td><td id="detailSWave"></td></tr>
        <tr><td>æ•°æ®æºï¼š</td><td id="detailSource"></td></tr>
      </table>
    </div>
    
    <h3 id="listTitle">å†å²åœ°éœ‡ï¼ˆæœ€è¿‘50æ¡ï¼‰</h3>
    <div id="list"></div>
    
    <div class="timeline-container">
      <strong>æ—¶é—´çº¿</strong>
      <div class="timeline" id="timeline"></div>
    </div>
  </div>
  
  <!-- å¤šç§éŸ³æ•ˆ -->
  <audio id="alert" src="data:audio/wav;base64,UklGRoABAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8A" preload="auto"></audio>
  <audio id="countdown" preload="auto"></audio>
  <audio id="srev" preload="auto"></audio>
  
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // ==================== æ€§èƒ½ä¼˜åŒ–éƒ¨åˆ† ====================
    
    // DOMç¼“å­˜
    const DOM = {
      map: null,
      mapLoading: document.getElementById('mapLoading'),
      mapClock: document.getElementById('mapClock'),
      clockLabel: document.getElementById('clockLabel'),
      clockSwitchBtn: document.getElementById('clockSwitchBtn'),
      status: document.getElementById('status'),
      lat: document.getElementById('lat'),
      lon: document.getElementById('lon'),
      saved: document.getElementById('saved'),
      sourceSelect: document.getElementById('sourceSelect'),
      minMag: document.getElementById('minMag'),
      maxDist: document.getElementById('maxDist'),
      timeRange: document.getElementById('timeRange'),
      copyInfo: document.getElementById('copyInfo'),
      list: document.getElementById('list'),
      quakeDetails: document.getElementById('quakeDetails'),
      detailPlace: document.getElementById('detailPlace'),
      detailMag: document.getElementById('detailMag'),
      detailTime: document.getElementById('detailTime'),
      detailIntensity: document.getElementById('detailIntensity'),
      detailDistance: document.getElementById('detailDistance'),
      detailPWave: document.getElementById('detailPWave'),
      detailSWave: document.getElementById('detailSWave'),
      detailSource: document.getElementById('detailSource'),
      timeline: document.getElementById('timeline'),
      alertBanner: document.getElementById('alertBanner'),
      alertText: document.getElementById('alertText'),
      replayControls: document.getElementById('replayControls'),
      replayToggleBtn: document.getElementById('replayToggleBtn'),
      replayPlayBtn: document.getElementById('replayPlayBtn'),
      replaySlider: document.getElementById('replaySlider'),
      replayTime: document.getElementById('replayTime'),
      replaySpeed: document.getElementById('replaySpeed'),
      performanceStats: document.getElementById('performanceStats'),
      dataCount: document.getElementById('dataCount'),
      memoryUsage: document.getElementById('memoryUsage')
    };

    // æ•°æ®ç¼“å­˜
    let cache = {
      earthquakeData: new Map(),
      lastFetchTime: 0,
      CACHE_DURATION: 60000 // 1åˆ†é’Ÿç¼“å­˜
    };

    // æ€§èƒ½ç›‘æ§
    const performance = {
      startTime: Date.now(),
      dataLoads: 0,
      memory: {
        getUsage: function() {
          if (performance.memory) {
            return (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
          }
          return 'N/A';
        }
      }
    };

    // ==================== æ ¸å¿ƒåŠŸèƒ½éƒ¨åˆ† ====================
    
    // æ—¶é’ŸåŠŸèƒ½
    let clockMode = "bj";
    
    function getBJTime() {
      let now = new Date();
      return new Date(now.getTime() + (8 - now.getTimezoneOffset()/60)*3600*1000);
    }
    
    function formatTime(dt) {
      return dt.getFullYear() + '-' + 
             ('0'+(dt.getMonth()+1)).slice(-2) + '-' +
             ('0'+dt.getDate()).slice(-2) + ' ' +
             ('0'+dt.getHours()).slice(-2) + ':' +
             ('0'+dt.getMinutes()).slice(-2) + ':' +
             ('0'+dt.getSeconds()).slice(-2);
    }
    
    function updateClock() {
      if (clockMode === "bj") {
        DOM.clockLabel.textContent = "åŒ—äº¬æ—¶é—´: " + formatTime(getBJTime());
        DOM.clockSwitchBtn.textContent = "åˆ‡æ¢ä¸ºæœ¬åœ°æ—¶é—´";
      } else {
        DOM.clockLabel.textContent = "æœ¬åœ°æ—¶é—´: " + formatTime(new Date());
        DOM.clockSwitchBtn.textContent = "åˆ‡æ¢ä¸ºåŒ—äº¬æ—¶é—´";
      }
    }
    
    function switchClockMode() {
      clockMode = clockMode === "bj" ? "local" : "bj";
      updateClock();
    }

    // è·ç¦»è®¡ç®— (ä¼˜åŒ–ç‰ˆ)
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)));
    }

    // çƒˆåº¦é¢œè‰²å’Œå›¾æ ‡
    function getIntensityColor(intensity) {
      if (!intensity) return "#3498db";
      const num = typeof intensity === 'number' ? intensity : parseInt(intensity);
      if (num >= 7) return "#e74c3c";
      if (num >= 5) return "#f39c12";
      if (num >= 3) return "#f1c40f";
      return "#2ecc71";
    }

    function getIntensityIcon(intensity) {
      const color = getIntensityColor(intensity);
      if (color === "#e74c3c") return "ğŸŸ¥";
      if (color === "#f39c12") return "ğŸŸ§";
      if (color === "#f1c40f") return "ğŸŸ¨";
      if (color === "#2ecc71") return "ğŸŸ©";
      return "ğŸŸ¦";
    }

    function getSourceName(source) {
      const sources = {
        cenc: "ä¸­å›½åœ°éœ‡å°ç½‘",
        usgs: "USGSå…¨çƒåœ°éœ‡",
        emsc: "EMSCå…¨çƒåœ°éœ‡",
        p2pquake: "P2PQuake",
        jma: "æ—¥æœ¬æ°”è±¡å…",
        test: "æµ‹è¯•æ•°æ®"
      };
      return sources[source] || source;
    }

    // ==================== åœ°å›¾åˆå§‹åŒ– ====================
    
    let map, userMarker, quakeMarkers = [], replayMarkers = [];
    let lat = parseFloat(localStorage.getItem('lat')) || 32;
    let lon = parseFloat(localStorage.getItem('lon')) || 110;
    
    DOM.lat.value = lat;
    DOM.lon.value = lon;

    function initMap() {
      map = L.map('map', {
        preferCanvas: true,
        zoomControl: false
      }).setView([lat, lon], 4);

      // åœ°å›¾å›¾å±‚
      const tileLayers = {
        gaode: L.tileLayer('https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}', {
          subdomains: ['1','2','3','4'],
          maxZoom: 18,
          attribution: 'Â© é«˜å¾·åœ°å›¾'
        }),
        osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 18,
          attribution: 'Â© OpenStreetMap contributors'
        }),
        satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
          maxZoom: 18,
          attribution: 'Tiles &copy; Esri'
        })
      };

      // å°è¯•åŠ è½½åœ°å›¾
      const layers = [tileLayers.gaode, tileLayers.osm, tileLayers.satellite];
      let currentIndex = 0;
      
      function tryNextLayer() {
        if (currentIndex >= layers.length) {
          console.error('æ‰€æœ‰åœ°å›¾æºéƒ½åŠ è½½å¤±è´¥');
          DOM.status.textContent = "åœ°å›¾åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥";
          return;
        }
        
        const layer = layers[currentIndex];
        layer.addTo(map)
          .on('load', function() {
            DOM.mapLoading.style.opacity = '0';
            setTimeout(() => DOM.mapLoading.style.display = 'none', 400);
            L.control.zoom({ position: 'topright' }).addTo(map);
          })
          .on('tileerror', function() {
            map.removeLayer(layer);
            currentIndex++;
            tryNextLayer();
          });
      }
      
      tryNextLayer();
      userMarker = L.marker([lat, lon], {title: "ä½ çš„ä½ç½®"}).addTo(map);
    }

    function switchMapStyle(style) {
      // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦ç®¡ç†å›¾å±‚
      DOM.status.textContent = `åˆ‡æ¢åˆ°${style}åœ°å›¾`;
    }

    // ==================== æ•°æ®ç®¡ç† ====================
    
    let earthquakeHistory = [];
    let filteredQuakes = [];
    let lastMaxQuakeTime = '';

    const API_URLS = {
      cenc: "https://api.ceic.ac.cn/earthquake?limit=50",
      usgs: "https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson",
      emsc: "https://www.seismicportal.eu/fdsnws/event/1/query?format=json&limit=50",
      p2pquake: "https://api.p2pquake.net/v2/history?codes=551&limit=50"
    };

    async function fetchQuakeData() {
      DOM.status.textContent = "æ•°æ®åŠ è½½ä¸­...";
      performance.dataLoads++;
      
      const source = DOM.sourceSelect.value;
      const cacheKey = `${source}_${Date.now()}`;
      
      // æ£€æŸ¥ç¼“å­˜
      if (cache.earthquakeData.has(cacheKey) && 
          Date.now() - cache.lastFetchTime < cache.CACHE_DURATION) {
        earthquakeHistory = cache.earthquakeData.get(cacheKey);
        applyFilters();
        return;
      }

      try {
        let quakes = [];
        
        if (source === "all") {
          const results = await Promise.allSettled([
            fetchUSGSData(),
            fetchCENCData(),
            fetchTestData()
          ]);
          
          results.forEach(result => {
            if (result.status === 'fulfilled' && result.value) {
              quakes = quakes.concat(result.value);
            }
          });
        } else {
          quakes = await fetchSpecificSource(source);
        }

        // æ•°æ®å¤„ç†
        quakes = quakes.filter(q => q && q.mag && q.time);
        quakes.sort((a, b) => new Date(b.time) - new Date(a.time));
        earthquakeHistory = quakes.slice(0, 50);
        
        // æ›´æ–°ç¼“å­˜
        cache.earthquakeData.set(cacheKey, earthquakeHistory);
        cache.lastFetchTime = Date.now();
        
        applyFilters();
        DOM.status.textContent = `å·²åŠ è½½ ${earthquakeHistory.length} æ¡æ•°æ®`;
        
      } catch (error) {
        console.error('è·å–æ•°æ®å¤±è´¥:', error);
        earthquakeHistory = getTestData();
        applyFilters();
        DOM.status.textContent = "ä½¿ç”¨æµ‹è¯•æ•°æ®";
      }
      
      updatePerformanceStats();
    }

    async function fetchUSGSData() {
      try {
        const response = await fetch(API_URLS.usgs);
        const data = await response.json();
        return data.features.map(f => ({
          mag: f.properties.mag,
          lat: f.geometry.coordinates[1],
          lon: f.geometry.coordinates[0],
          place: f.properties.place,
          time: new Date(f.properties.time).toISOString(),
          intensity: "",
          source: "usgs"
        }));
      } catch (error) {
        return [];
      }
    }

    async function fetchCENCData() {
      try {
        const response = await fetch(API_URLS.cenc);
        const data = await response.json();
        return data.earthquakes ? data.earthquakes.map(e => ({
          mag: e.magnitude,
          lat: e.latitude,
          lon: e.longitude,
          place: e.location,
          time: e.time,
          intensity: e.intensity || "",
          source: "cenc"
        })) : [];
      } catch (error) {
        return [];
      }
    }

    function getTestData() {
      const now = new Date();
      return [
        {
          mag: 6.5,
          lat: 34.0,
          lon: 118.0,
          place: "æµ‹è¯•åœ°éœ‡ - åä¸œåœ°åŒº",
          time: new Date(now.getTime() - 2 * 60 * 60 * 1000).toISOString(),
          intensity: "6",
          source: "test"
        },
        {
          mag: 5.2,
          lat: 30.0,
          lon: 110.0,
          place: "æµ‹è¯•åœ°éœ‡ - åä¸­åœ°åŒº", 
          time: new Date(now.getTime() - 4 * 60 * 60 * 1000).toISOString(),
          intensity: "5",
          source: "test"
        }
      ];
    }

    async function fetchSpecificSource(source) {
      return getTestData(); // ç®€åŒ–å®ç°
    }

    async function fetchTestData() {
      return getTestData();
    }

    // ==================== æ˜¾ç¤ºåŠŸèƒ½ ====================
    
    function applyFilters() {
      const minMag = parseFloat(DOM.minMag.value) || 0;
      const maxDist = parseFloat(DOM.maxDist.value) || 10000;
      const timeRange = parseFloat(DOM.timeRange.value) || 24;
      
      const userLat = parseFloat(DOM.lat.value);
      const userLon = parseFloat(DOM.lon.value);
      const timeThreshold = new Date(Date.now() - timeRange * 60 * 60 * 1000);
      
      filteredQuakes = earthquakeHistory.filter(q => {
        if (parseFloat(q.mag) < minMag) return false;
        if (new Date(q.time) < timeThreshold) return false;
        if (q.lat && q.lon) {
          const dist = haversine(userLat, userLon, q.lat, q.lon);
          if (dist > maxDist) return false;
        }
        return true;
      });
      
      renderList(filteredQuakes);
      addQuakeMarkers(filteredQuakes);
      renderTimeline(filteredQuakes);
      triggerAlert(filteredQuakes);
      updatePerformanceStats();
    }

    function renderList(quakes) {
      const userLat = parseFloat(DOM.lat.value);
      const userLon = parseFloat(DOM.lon.value);
      
      if (!quakes || quakes.length === 0) {
        DOM.list.innerHTML = "<div>æš‚æ— åœ°éœ‡æ•°æ®</div>";
        return;
      }
      
      // ä½¿ç”¨DocumentFragmentä¼˜åŒ–DOMæ“ä½œ
      const fragment = document.createDocumentFragment();
      
      quakes.forEach((q, index) => {
        const dist = (q.lat && q.lon) ? haversine(userLat, userLon, q.lat, q.lon) : null;
        const pWave = dist ? (dist / 6).toFixed(1) : "?";
        const sWave = dist ? (dist / 3.5).toFixed(1) : "?";
        const intensityIcon = getIntensityIcon(q.intensity);
        const intensityColor = getIntensityColor(q.intensity);
        
        const item = document.createElement('div');
        item.className = 'item';
        item.style.borderLeftColor = intensityColor;
        item.onclick = () => showQuakeDetails(index);
        
        item.innerHTML = `
          <span class="icon">${intensityIcon}</span>
          <span class="mag">M${q.mag}</span>
          <span class="dist">${dist ? dist.toFixed(1)+'km' : 'æœªçŸ¥è·ç¦»'}</span>
          <span class="intensity">çƒˆåº¦/éœ‡åº¦ï¼š${q.intensity || "æœªçŸ¥"}</span>
          <div style="margin-left:34px">
            <span>${q.place}</span>
            <span class="source-badge">${getSourceName(q.source)}</span>
          </div>
          <div style="margin-left:34px; font-size: 12px; color: #666;">
            <span class="quake-time">${new Date(q.time).toLocaleString()}</span>
          </div>
        `;
        
        fragment.appendChild(item);
      });
      
      DOM.list.innerHTML = '';
      DOM.list.appendChild(fragment);
    }

    function showQuakeDetails(index) {
      const q = filteredQuakes[index];
      const userLat = parseFloat(DOM.lat.value);
      const userLon = parseFloat(DOM.lon.value);
      const dist = (q.lat && q.lon) ? haversine(userLat, userLon, q.lat, q.lon) : null;
      const pWave = dist ? (dist / 6).toFixed(1) : "?";
      const sWave = dist ? (dist / 3.5).toFixed(1) : "?";
      
      DOM.detailPlace.textContent = q.place;
      DOM.detailMag.textContent = `M${q.mag}`;
      DOM.detailTime.textContent = new Date(q.time).toLocaleString();
      DOM.detailIntensity.textContent = q.intensity || "æœªçŸ¥";
      DOM.detailDistance.textContent = dist ? `${dist.toFixed(1)} km` : "æœªçŸ¥";
      DOM.detailPWave.textContent = `${pWave} ç§’`;
      DOM.detailSWave.textContent = `${sWave} ç§’`;
      DOM.detailSource.textContent = getSourceName(q.source);
      
      DOM.quakeDetails.style.display = 'block';
      copyToClipboard(`${q.place} | M${q.mag} | ${new Date(q.time).toLocaleString()} | æ•°æ®æº: ${getSourceName(q.source)}`);
    }

    function addQuakeMarkers(quakes) {
      // æ¸…é™¤ç°æœ‰æ ‡è®°
      quakeMarkers.forEach(m => map.removeLayer(m));
      quakeMarkers = [];
      
      const userLat = parseFloat(DOM.lat.value);
      const userLon = parseFloat(DOM.lon.value);
      
      quakes.forEach(q => {
        if (q.lat && q.lon && !isNaN(q.lat) && !isNaN(q.lon)) {
          const dist = haversine(userLat, userLon, q.lat, q.lon);
          const pWave = (dist / 6).toFixed(1);
          const sWave = (dist / 3.5).toFixed(1);
          const color = getIntensityColor(q.intensity);
          
          const marker = L.circleMarker([q.lat, q.lon], {
            radius: Math.max(6, q.mag * 3),
            color: color,
            fillColor: color,
            fillOpacity: 0.7,
            weight: 2
          }).addTo(map);
          
          marker.bindPopup(`
            <b>${getIntensityIcon(q.intensity)} åœ°éœ‡ä¿¡æ¯</b><br>
            <b>åœ°ç‚¹</b>: ${q.place}<br>
            <b>æ—¶é—´</b>: ${new Date(q.time).toLocaleString()}<br>
            <b>éœ‡çº§</b>: M${q.mag}<br>
            <b>çƒˆåº¦</b>: ${q.intensity || "æœªçŸ¥"}<br>
            <b>è·ç¦»ä½ </b>: ${dist.toFixed(1)}km<br>
            <b>Pæ³¢åˆ°è¾¾</b>: ${pWave}ç§’<br>
            <b>Sæ³¢åˆ°è¾¾</b>: ${sWave}ç§’<br>
            <b>æ•°æ®æº</b>: ${getSourceName(q.source)}
          `);
          
          quakeMarkers.push(marker);
        }
      });
      
      // è°ƒæ•´è§†å›¾
      if (quakeMarkers.length > 0) {
        const group = new L.featureGroup(quakeMarkers);
        map.fitBounds(group.getBounds().pad(0.1));
      }
    }

    function renderTimeline(quakes) {
      DOM.timeline.innerHTML = '';
      if (!quakes || quakes.length === 0) return;
      
      const times = quakes.map(q => new Date(q.time).getTime());
      const minTime = Math.min(...times);
      const maxTime = Math.max(...times);
      const timeRange = maxTime - minTime;
      
      quakes.forEach((q, index) => {
        const quakeTime = new Date(q.time).getTime();
        const position = ((quakeTime - minTime) / timeRange) * 100;
        
        const marker = document.createElement('div');
        marker.className = 'timeline-marker';
        marker.style.left = `${position}%`;
        marker.style.ba
